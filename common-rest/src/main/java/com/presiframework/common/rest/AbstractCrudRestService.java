/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.presiframework.common.rest;

import com.presiframework.common.datalayer.entities.exceptions.RequiredFieldException;
import com.presiframework.common.datalayer.entities.exceptions.NoDataFoundException;
import com.presiframework.common.service.exception.InternalServiceException;
import com.presiframework.common.datalayer.entities.CommonEntity;

import com.presiframework.common.rest.dto.CommonDto;
import com.presiframework.common.rest.handler.exception.ExceptionHandler;
import com.presiframework.common.rest.mapper.EntityDtoMapper;
import com.presiframework.common.rest.response.ResponseDataID;
import com.presiframework.common.rest.response.ResponseStatus;
import com.presiframework.common.rest.response.RestServiceResponse;
import com.presiframework.common.service.CrudService;
import com.presiframework.common.datalayer.repository.SearchCriteria;
import java.util.List;
import java.util.function.Function;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.hateoas.server.mvc.ControllerLinkBuilder;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;

/**
 *
 * @author Miguel Presinal <presinal378@gmail.com>
 * @param <D>
 * @param <E>
 * @param <C>
 * @since 1.0
 */
public abstract class AbstractCrudRestService<
        D extends CommonDto, 
        E extends CommonEntity<Long>, 
        C extends SearchCriteria> implements CrudRestService<D, C> {

    private static final Logger logger = LoggerFactory.getLogger(AbstractCrudRestService.class);

    private boolean autoGeneratedKey;

    public AbstractCrudRestService() {
        this.autoGeneratedKey = true;
    }

    public AbstractCrudRestService(boolean autoGeneratedKey) {
        this.autoGeneratedKey = autoGeneratedKey;
    }

    public abstract <F extends SearchCriteria> CrudService<E, F> getServiceProvider();

    public abstract EntityDtoMapper<D, E> getEntityDtoMapper();

    /**
     *
     * @return
     */
    protected ExceptionHandler getExceptionHandler() {
        return ExceptionHandler.getInstance();
    }

    private ResponseEntity<RestServiceResponse<D>> createUpdate(D dto, boolean updateMode) {
        final String METHOD = "createUpdate():: ";
        logger.info(METHOD + "Enter");
        logger.info(METHOD + "** dto = " + dto);
        logger.info(METHOD + "** updateMode = " + updateMode);

        RestServiceResponse<D> response = new RestServiceResponse<>(ResponseStatus.OK);
        HttpStatus responseStatus = HttpStatus.CREATED;

        try {

            logger.debug(METHOD + "Validating dto...");
            if (dto == null) {
                throw new RequiredFieldException();
            }
            logger.debug(METHOD + "Validating dto...OK");

            EntityDtoMapper<D, E> mapper = getEntityDtoMapper();

            logger.debug(METHOD + "Converting dto a entity...");
            E entity = mapper.toEntity(dto);
            logger.debug(METHOD + "** entity = " + entity);

            logger.debug(METHOD + "Saving entity...");

            if (updateMode) {
                getServiceProvider().update(entity);
            } else {
                getServiceProvider().create(entity);
            }
            logger.debug(METHOD + "Saving entity...OK");

            if (this.autoGeneratedKey || updateMode) {
                try {
                    entity = getServiceProvider().findById(entity.getId());
                    mapper.refreshDto(dto, entity);
                } catch (InternalServiceException e) {

                    if (e.getCause() instanceof UnsupportedOperationException) {
                        logger.warn(METHOD + "dto can not be updated to the latter changes. "
                                + getServiceProvider().getClass().getName() + ".findById(Long) is not implemented");

                    } else {
                        throw e;
                    }
                }
            }

            dto.setLink(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(this.getClass()).findById(dto.getId())).withSelfRel().getHref());
            response.setData(dto);

        } catch (Exception e) {
            logger.error(METHOD + e.getMessage(), e);

            responseStatus = getExceptionHandler().getStatusCodeForException(e);
            response.setStatus(ResponseStatus.ERROR);
            response.setErrors(getExceptionHandler().extractErrorMessagesFromException(e));
        }

        logger.debug(METHOD + "Returning response = " + response);
        logger.info(METHOD + "Exit");
        return ResponseEntity.status(responseStatus).<RestServiceResponse<D>>body(response);
    }

    @Override
    public ResponseEntity<RestServiceResponse<D>> create(@RequestBody D dto) {
        final String METHOD = "create():: ";
        logger.info(METHOD + "Enter");
        ResponseEntity response = createUpdate(dto, false);

        logger.debug(METHOD + "Returning response = " + response.getBody());
        logger.info(METHOD + "Exit");
        return response;
    }

    @Override
    public ResponseEntity<RestServiceResponse<D>> update(@RequestBody D dto) {
        final String METHOD = "update():: ";
        logger.info(METHOD + "Enter");
        ResponseEntity response = createUpdate(dto, true);

        logger.debug(METHOD + "Returning response = " + response.getBody());
        logger.info(METHOD + "Exit");
        return response;
    }

    @Override
    public ResponseEntity<RestServiceResponse<ResponseDataID>> delete(@PathVariable Long id) {
        final String METHOD = "delete():: ";
        logger.info(METHOD + "Enter");
        logger.info(METHOD + "id = " + id);

        RestServiceResponse<ResponseDataID> response = new RestServiceResponse<>(ResponseStatus.OK);
        HttpStatus responseStatus = HttpStatus.OK;

        try {

            logger.debug(METHOD + "Finding entity width id:" + id + "...");
            E e = getServiceProvider().findById(id);
            logger.debug(METHOD + "Finding entity width id:" + id + "...OK");

            logger.debug(METHOD + "Deleting entity...");
            getServiceProvider().delete(e);
            logger.debug(METHOD + "Deleting entity...OK");

        } catch (Exception e) {
            logger.error(METHOD + "Unexpected error has occurred. " + e.getMessage(), e);

            responseStatus = getExceptionHandler().getStatusCodeForException(e);
            response.setStatus(ResponseStatus.ERROR);
            response.setErrors(getExceptionHandler().extractErrorMessagesFromException(e));
        }

        logger.debug(METHOD + "Returning response = " + response);
        logger.info(METHOD + "Exit");
        return ResponseEntity.status(responseStatus).<RestServiceResponse<ResponseDataID>>body(response);
    }

    @Override
    public ResponseEntity<RestServiceResponse<ResponseDataID>> batchDelete(@RequestBody List<Long> ids) {
        final String METHOD = "batchDelete():: ";
        logger.info(METHOD + "Enter");
        logger.info(METHOD + "ids = " + ids);

        RestServiceResponse<ResponseDataID> response = new RestServiceResponse<>(ResponseStatus.OK);
        HttpStatus responseStatus = HttpStatus.OK;

        try {

            logger.debug(METHOD + "Deleting entity...");
            boolean isDeleted = getServiceProvider().delete(ids);
            logger.debug(METHOD + "isDeleted = " + isDeleted);
            logger.debug(METHOD + "Deleting entity...OK");

        } catch (Exception e) {
            logger.error(METHOD + "Unexpected error has occurred. " + e.getMessage(), e);

            responseStatus = getExceptionHandler().getStatusCodeForException(e);
            response.setStatus(ResponseStatus.ERROR);
            response.setErrors(getExceptionHandler().extractErrorMessagesFromException(e));
        }

        logger.debug(METHOD + "Returning response = " + response);
        logger.info(METHOD + "Exit");
        return ResponseEntity.status(responseStatus).<RestServiceResponse<ResponseDataID>>body(response);
    }

    @Override
    public ResponseEntity<RestServiceResponse<D>> findById(@PathVariable Long id) {
        final String METHOD = "findById() :: ";
        logger.info(METHOD + "Enter");
        logger.info(METHOD + "id = " + id);
        EntityDtoMapper<D, E> mapper = getEntityDtoMapper();
        RestServiceResponse<D> response = new RestServiceResponse<>(ResponseStatus.OK);
        HttpStatus responseStatus = HttpStatus.OK;

        try {
            logger.debug(METHOD + "Finding entity by id...");

            E entity = getServiceProvider().findById(id);

            logger.debug(METHOD + "entity = " + entity);
            logger.debug(METHOD + "Finding entity by id...OK");
            D dto = mapper.toDto(entity);
            dto.setLink(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(this.getClass()).findById(id)).withSelfRel().getHref());
            response.setData(dto);

        } catch (InternalServiceException | NoDataFoundException e) {
            logger.error(METHOD + "Unexpected error has occurred. " + e.getMessage(), e);

            responseStatus = getExceptionHandler().getStatusCodeForException(e);
            response.setStatus(ResponseStatus.ERROR);
            response.setErrors(getExceptionHandler().extractErrorMessagesFromException(e));

        }

        logger.debug(METHOD + "Returning response = " + response);
        logger.info(METHOD + "Exit");
        return ResponseEntity.status(responseStatus).<RestServiceResponse<D>>body(response);
    }

    @Override
    public ResponseEntity<RestServiceResponse<List<D>>> findAll() {
        final String METHOD = "findAll() :: ";
        logger.info(METHOD + "Enter");

        EntityDtoMapper<D, E> mapper = getEntityDtoMapper();
        return findAllAndMap(mapper::toDtoList);
    }

    /**
     * 
     * Find all entities in the repository using  and map the result using a custom entity-dto-mapper.
     * This method is useful when you have an entity with relation ships and you don't want
     * to load the related entities, which are usually loaded when call the getter of the field
     * that hold the relation ship.
     *
     * @param mapper an implementation of Function<Iterable<E>, List<D>> that do the mapping between dto and entity
     * @return
     */
    protected ResponseEntity<RestServiceResponse<List<D>>> findAllAndMap(Function<Iterable<E>, List<D>> mapper) {
        final String METHOD = "findAllAndMap() :: ";
        logger.info(METHOD + "Enter");

        RestServiceResponse<List<D>> response = new RestServiceResponse<>(ResponseStatus.OK);
        HttpStatus responseStatus = HttpStatus.OK;

        try {
            logger.debug(METHOD + "Finding all entities...");
            Iterable<E> list = getServiceProvider().findAll();
            logger.debug(METHOD + "Finding all entities...OK");
            response.setData(mapper.apply(list));
            response.getData().forEach(d -> {
                d.setLink(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(this.getClass()).findById(d.getId())).withSelfRel().getHref());
            });

        } catch (Exception e) {
            logger.error(METHOD + "Unexpected error has occurred. " + e.getMessage(), e);

            responseStatus = getExceptionHandler().getStatusCodeForException(e);
            response.setStatus(ResponseStatus.ERROR);
            response.setErrors(getExceptionHandler().extractErrorMessagesFromException(e));
        }

        logger.debug(METHOD + "Returning response = " + response);
        logger.info(METHOD + "Exit");
        return ResponseEntity.status(responseStatus).<RestServiceResponse<List<D>>>body(response);
    }

    @Override
    public ResponseEntity<RestServiceResponse<List<D>>> doFilter(@ModelAttribute C criteria) {
        final String METHOD = "doFilter() :: ";
        logger.info(METHOD + "Enter");
        logger.info(METHOD + " parameter :: criterios = " + criteria);

        EntityDtoMapper<D, E> mapper = getEntityDtoMapper();
        return filterAndMap(criteria, mapper::toDtoList);
    }

    /**
     * 
     * Do a search in the repository using a search criteria and map the result using a custom entity-dto-mapper.
     * This method is useful when you have an entity with relation ships and you don't want
     * to load the related entities, which are usually loaded when call the getter of the field
     * that hold the relation ship.
     *
     * @param criteria
     * @param mapper an implementation of Function<Iterable<E>, List<D>> that do the mapping between dto and entity
     * @return
     */
    protected ResponseEntity<RestServiceResponse<List<D>>> filterAndMap(C criteria, Function<Iterable<E>, List<D>> mapper) {
        final String METHOD = "filterAndMap() :: ";
        logger.info(METHOD + "Enter");
        logger.info(METHOD + " parameter :: criteria = " + criteria);
        logger.info(METHOD + " parameter :: mapper = " + mapper);

        if (!(criteria instanceof SearchCriteria)) {
            throw new IllegalArgumentException("criterios must be an implemetation of SearchCriteria");
        }

        RestServiceResponse<List<D>> response = new RestServiceResponse<>(ResponseStatus.OK);
        HttpStatus responseStatus = HttpStatus.OK;

        try {
            logger.debug(METHOD + "Finding all entities...");
            Iterable<E> list = getServiceProvider().filter((SearchCriteria) criteria);
            logger.debug(METHOD + "Finding all entities...OK");
            response.setData(mapper.apply(list));

            response.getData().forEach(d -> {
                d.setLink(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(this.getClass()).findById(d.getId())).withSelfRel().getHref());
            });

        } catch (Exception e) {
            logger.error(METHOD + "Unexpected error has occurred. " + e.getMessage(), e);

            responseStatus = getExceptionHandler().getStatusCodeForException(e);
            response.setStatus(ResponseStatus.ERROR);
            response.setErrors(getExceptionHandler().extractErrorMessagesFromException(e));
        }

        logger.debug(METHOD + "Returning response = " + response);
        logger.info(METHOD + "Exit");
        return ResponseEntity.status(responseStatus).<RestServiceResponse<List<D>>>body(response);
    }
}
